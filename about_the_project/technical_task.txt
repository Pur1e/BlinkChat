Техническое задание: Система управления бронированием ресурсов с интеграцией оплаты и расширенными ролями

1. Описание проекта

Разработать систему управления бронированием ресурсов, таких как переговорные комнаты, оборудование или автомобили,
с поддержкой различных платежных систем. Система должна поддерживать три роли: Администратор, Пользователь (User) и Гость (Guest).
Пользователи могут публиковать и управлять своими ресурсами, гости могут просматривать доступные ресурсы для аренды.
Для улучшения структуры системы добавлена возможность управления категориями ресурсов.

2. Функциональные требования

2.1. Роли и права доступа

	1.	Администратор:
	•	Полный доступ к системе.
	•	Управление всеми ресурсами, категориями и бронированиями.
	•	Добавление, редактирование и удаление ресурсов и категорий.
	•	Активация и деактивация ресурсов.
	•	Управление пользователями, бронированиями и платежами.
	2.	Пользователь (User):
	•	Публикация и управление только своими ресурсами.
	•	Просмотр и управление бронированиями своих ресурсов.
	•	Возможность активировать и деактивировать свои ресурсы.
	•	Создание и редактирование бронирований для своих ресурсов.
	•	Нет прав на управление чужими ресурсами и бронированиями.
	3.	Гость (Guest):
	•	Просмотр всех доступных ресурсов и категорий.
	•	Фильтрация ресурсов по категориям и статусам.
	•	Нет доступа к управлению ресурсами, бронированиям и платежам.
	•	Возможность регистрироваться для получения роли пользователя.

2.2. Управление ресурсами

	•	Ресурсы (переговорные комнаты, автомобили, оборудование и т.д.) могут быть активными или неактивными.
	•	Категории ресурсов помогут организовать их по тематике и улучшить навигацию для пользователей.
	•	Пользователи могут публиковать свои ресурсы и управлять ими.

Поля ресурса:

	•	Уникальный идентификатор (UUID).
	•	Имя.
	•	Описание.
	•	Статус (активный или неактивный).
	•	Владелец ресурса (ID пользователя).
	•	Категория ресурса (ID категории).

2.3. Управление категориями

	•	Иерархическая структура категорий (возможность создания подкатегорий).
	•	Категория может иметь родительскую категорию, что позволяет создавать вложенные категории для лучшей структуризации.

Поля категории:

	•	Уникальный идентификатор (ID).
	•	Имя категории.
	•	Родительская категория (ID).

2.4. Управление бронированиями

	•	Пользователи могут бронировать ресурсы на определённое время.
	•	Система должна проверять доступность ресурса, чтобы не допускать конфликтующих бронирований.
	•	Бронирование подтверждается только после успешной оплаты.
	•	Администратор может управлять бронированиями всех пользователей.

2.5. Интеграция оплаты

	•	Поддержка нескольких платёжных систем, таких как PayPal, банковские карты и т.д.
	•	Поддержка моментальных и отложенных платежей.
	•	Обработка успешных и неудачных транзакций с соответствующими уведомлениями для пользователей.

2.6. Журналирование

	•	Все действия в системе логируются (создание, изменение, удаление ресурсов и бронирований, платежи).
	•	Журнал должен содержать информацию о пользователе, который инициировал действие, и временную метку.
	•	Ошибки логируются с минимальным количеством информации, без лишней утечки библиотечных вызовов.

2.7. API

	•	Все функциональные возможности системы должны быть доступны через REST API.
	•	Аутентификация и авторизация через JWT.
	•	API должно быть хорошо документировано с использованием Swagger или аналогичного инструмента.

2.8. Чат

	•	Реализовать функцию чата один-на-один между пользователями.
	•	Чат в реальном времени, реализованный с использованием Websockets.
	•	Администратор может отслеживать чаты.

2.9. Оптимизация и производительность

	•	Система должна справляться с высоким количеством запросов на бронирование, оплату и обновления.
	•	Использование Redis для кэширования часто запрашиваемых данных.
	•	Возможна реализация очередей сообщений для обработки задач (например, Kafka/RabbitMQ).

3. Архитектура системы

3.1. Микросервисы

	1.	Authentication Service:
	•	Аутентификация и авторизация пользователей с использованием JWT.
	•	Управление ролями (Администратор, User, Guest).
	2.	Resource Service:
	•	Управление ресурсами и категориями.
	•	Проверка доступности ресурсов для бронирования.
	3.	Booking Service:
	•	Управление бронированиями ресурсов.
	•	Проверка доступности на выбранные даты.
	4.	Payment Service:
	•	Интеграция с различными платёжными системами.
	•	Управление статусами платежей (успешные, неудачные, отмененные).
	5.	Notification Service:
	•	Уведомления пользователей о статусах бронирований и платежей.
	6.	Chat Service:
	•	Реализация чатов в реальном времени с использованием Websockets.
	7.	Audit Service:
	•	Логирование всех действий пользователей в системе для аудита.

3.2. Базы данных

	1.	PostgreSQL:
	•	Используется для хранения основной информации о пользователях, ресурсах, категориях, бронированиях и платежах.
	•	Схема базы данных должна включать следующие сущности:
	•	Пользователи (Users): хранит данные о пользователях, их ролях (Администратор, User, Guest).
	•	Ресурсы (Resources): хранит информацию о ресурсах (ID, имя, описание, статус, владелец).
	•	Категории (Categories): содержит категории для группировки ресурсов (ID, имя, родительская категория).
	•	Бронирования (Bookings): хранит данные о бронированиях ресурсов (ID ресурса, пользователь, даты бронирования, статус бронирования).
	•	Платежи (Payments): хранит данные о транзакциях (ID бронирования, статус оплаты, дата оплаты, сумма).
	•	Чаты (Chats): хранит данные об обмене сообщениями между пользователями.
	•	Логи (Audit): хранит информацию о действиях пользователей (создание, изменение, удаление, оплата).
	2.	Redis:
	•	Используется для кэширования часто запрашиваемых данных, таких как доступные ресурсы и категории.
	•	Хранение данных, которые могут часто изменяться и требовать быстрого доступа, например, состояния чатов или кэширования бронирований для проверки доступности ресурса.

3.3. Компоненты системы

	1.	API Gateway:
	•	Центральная точка доступа для всех клиентских запросов.
	•	Обрабатывает аутентификацию, маршрутизацию запросов на соответствующие микросервисы, балансировку нагрузки.
	•	Работает с JWT токенами для авторизации и передачи информации о пользователях к микросервисам.
	2.	gRPC:
	•	Используется для быстрой и эффективной коммуникации между микросервисами. Обеспечивает низкую задержку и высокую производительность.
	3.	Kafka/RabbitMQ:
	•	Очереди сообщений используются для асинхронной обработки событий (например, подтверждение бронирования после успешной оплаты, уведомление пользователей о событиях).
	•	Kafka или RabbitMQ могут использоваться для обработки высоких нагрузок и обеспечения отказоустойчивости.
	4.	WebSockets:
	•	Используется для реализации реального времени в чате. Обеспечивает мгновенные уведомления о новых сообщениях между пользователями.
	5.	Eureka:
	•	Служба обнаружения для микросервисов, которая помогает системе находить и взаимодействовать с другими сервисами.

4. Нефункциональные требования

4.1. Тестирование

	•	Юнит-тесты:
	•	Покрытие основных бизнес-компонентов юнит-тестами (JUnit/Mockito).
	•	Критические модули (платежи, бронирования, управление ресурсами) должны иметь высокое покрытие тестами.
	•	Интеграционные тесты:
	•	Проверка взаимодействия между микросервисами и с внешними API (например, платёжными системами).
	•	Тестирование правильности обработки запросов, синхронизации между микросервисами.

4.2. Документация

	•	Swagger:
	•	Используется для генерации и поддержки документации по REST API.
	•	Описание всех конечных точек API, включая параметры запроса, ответы и возможные ошибки.
	•	Комментарии в коде:
	•	Важные участки кода должны быть задокументированы для улучшения читаемости и поддержки системы.

4.3. Контейнеризация

	•	Docker:
	•	Все микросервисы должны быть контейнеризованы для упрощения развёртывания и масштабирования.
	•	Использование Docker Compose для локальной разработки и тестирования.
	•	CI/CD (Jenkins):
	•	Настройка автоматической сборки, тестирования и деплоя через Jenkins.
	•	Автоматическое развёртывание в различные среды (тестирование, продакшн).

4.4. Безопасность

	•	JWT (JSON Web Tokens):
	•	Используется для аутентификации и авторизации пользователей. Каждый пользователь, после успешной авторизации, получает JWT токен, который передается в каждом последующем запросе для подтверждения его прав.
	•	Токен содержит информацию о роли пользователя (Administrator, User, Guest) и сроке его действия.
	•	Аутентификация и авторизация на уровне микросервисов. Только авторизованные пользователи могут выполнять действия, доступные для их роли.
	•	Spring Security:
	•	Используется для обеспечения безопасности на уровне API.
	•	Реализует контроль доступа на основе ролей, проверяя авторизован ли пользователь для выполнения конкретных операций (например, администратор может управлять всеми ресурсами, а User — только своими).
	•	Настройка защиты REST API от несанкционированных запросов и атак (например, защита от CSRF, brute force).
	•	Шифрование данных:
	•	Все пароли пользователей должны храниться в зашифрованном виде с использованием современных алгоритмов хеширования, таких как bcrypt.
	•	Чувствительные данные (например, информация о платежах) должны быть зашифрованы и храниться безопасно.
	•	Ограничение количества запросов (Rate Limiting):
	•	Защита от чрезмерного количества запросов и DDoS-атак. Реализовать ограничения на количество запросов от одного пользователя в определённый промежуток времени.

4.5. Логирование и аудит

	•	Логирование действий пользователей:
	•	Все действия пользователей (создание, изменение, удаление ресурсов, бронирование, оплата) должны логироваться для возможности последующего аудита. Логирование должно содержать информацию о пользователе, дате и времени действия, а также подробности о том, что было сделано.
	•	Использование библиотеки логирования (например, Logback или Log4j2) для настройки логирования на уровне микросервисов.
	•	Обработка ошибок:
	•	Все ошибки должны быть обработаны и записаны в журнал. При этом сообщения об ошибках для пользователя должны быть понятны, не должны содержать технических деталей или стек-трейсов, которые могут предоставить информацию злоумышленникам.
	•	Журналы ошибок должны содержать информацию о типе ошибки, дате и времени, а также контекст, в котором произошла ошибка.
	•	Аудит платежей:
	•	Все транзакции должны быть задокументированы в журнале аудита с указанием статуса (успешная, неуспешная), суммы, времени платежа и информации о пользователе.

5. Микросервисы

	•	User Service: Управление пользователями и их ролями. Поддерживает аутентификацию и авторизацию.
	•	Resource Service: Управление ресурсами, категориями и доступностью. Реализует CRUD-операции для ресурсов и категорий.
	•	Booking Service: Управление бронированиями ресурсов, проверка доступности, обработка конфликтов бронирования.
	•	Payment Service: Интеграция с различными платежными системами (например, PayPal, Stripe), обработка платежей и отмена бронирований в случае неуспешной транзакции.
	•	Notification Service: Управление уведомлениями для пользователей о событиях, связанных с их бронированиями и оплатами.
	•	Chat Service: Реализация функционала чатов для обмена сообщениями между пользователями в реальном времени с использованием WebSockets.
	•	Audit Service: Логирование всех действий и ошибок, связанных с пользователями, бронированиями и платежами.

6. Оптимизация и производительность

	•	Кэширование (Redis):
	•	Для повышения производительности используется Redis для кэширования часто запрашиваемых данных (например, доступных ресурсов, категорий и бронирований).
	•	Кэширование должно учитывать актуальность данных и автоматически сбрасываться при изменении информации (например, изменение состояния ресурса или бронирования).
	•	Очереди сообщений (Kafka/RabbitMQ):
	•	Использование Kafka или RabbitMQ для асинхронной обработки событий, таких как подтверждение бронирования после успешной оплаты или уведомления о новых сообщениях в чате.
	•	Это поможет системе справляться с высоким количеством запросов и позволит обрабатывать транзакции и бронирования в фоновом режиме без блокировки пользователя.
	•	Масштабируемость:
	•	Все микросервисы должны быть легко масштабируемыми. Контейнеризация с Docker и использование Kubernetes для автоматического масштабирования при увеличении нагрузки.
	•	API Gateway должен балансировать нагрузку между микросервисами и управлять их доступностью.

7. Документация

	•	Swagger:
	•	Для каждого микросервиса должна быть доступна Swagger-документация для взаимодействия с API.
	•	Все конечные точки (endpoints) должны быть задокументированы с указанием входных и выходных параметров, возможных ошибок и примеров запросов.
	•	Комментарии в коде:
	•	Код должен содержать комментарии, поясняющие ключевые участки логики и структуру системы, что облегчит её сопровождение и доработку.

8. CI/CD и деплой

	•	Jenkins:
	•	Настроить CI/CD pipeline для автоматической сборки, тестирования и деплоя микросервисов.
	•	Каждый новый коммит в ветку должен автоматически запускать юнит и интеграционные тесты, а затем развёртывание в тестовую среду.
	•	В случае успешного прохождения всех тестов происходит автоматический деплой на продакшн.
	•	Docker и Kubernetes:
	•	Использование Docker для контейнеризации микросервисов.
	•	Kubernetes для управления контейнерами, оркестрации и автоматического масштабирования приложения в зависимости от нагрузки.